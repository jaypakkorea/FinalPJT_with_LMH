"use strict";Object.defineProperty(exports, "__esModule", {value: true});

var _chunk3B5L5EN5js = require('./chunk-3B5L5EN5.js');

// src/core/loader.ts
var _jsontools = require('@iconify/json-tools');

// src/core/compilers/jsx.ts
async function JSXCompiler(svg, collection, icon, style = "react") {
  const svgr = _chunk3B5L5EN5js.__require.call(void 0, "@svgr/core").default;
  let res = await svgr(svg, { icon: true }, { componentName: camel(`${collection}-${icon}`) });
  if (style === "preact")
    res = res.replace('import * as React from "react";', "");
  return res;
}
function camel(str) {
  return str.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
}

// src/core/compilers/vue2.ts
function Vue2Compiler(svg, collection, icon) {
  const { compile } = _chunk3B5L5EN5js.__require.call(void 0, "vue-template-compiler");
  const transpile = _chunk3B5L5EN5js.__require.call(void 0, "vue-template-es2015-compiler");
  svg = svg.replace("<svg ", "<svg v-pre ");
  const { render } = compile(svg);
  const toFunction = (code2) => {
    return `function () {${code2}}`;
  };
  let code = transpile(`var __render__ = ${toFunction(render)}
`, {});
  code = code.replace(/\s__(render|staticRenderFns)__\s/g, " $1 ");
  code += `
/* vite-plugin-components disabled */
export default {
  render: render,
  name: '${collection}-${icon}',
}
`;
  return code;
}

// src/core/compilers/vue3.ts
function Vue3Compiler(svg, collection, icon) {
  const { compileTemplate } = _chunk3B5L5EN5js.__require.call(void 0, "@vue/compiler-sfc");
  svg = svg.replace("<svg ", "<svg v-pre ");
  let { code } = compileTemplate({
    source: svg,
    id: `${collection}:${icon}`,
    filename: `${collection}-${icon}.vue`
  });
  code = code.replace(/^export /g, "");
  code += `

export default { name: '${collection}-${icon}', render }`;
  code += "\n/* vite-plugin-components disabled */";
  return code;
}

// src/core/compilers/solid.ts
async function SolidCompiler(svg) {
  return `
    import { template, spread } from "solid-js/web";

    const _tmpl$ = template(\`${svg}\`, 0);
    export default (props = {}) => {
        const _el$ = _tmpl$.cloneNode(true);
        spread(_el$, props, true);
        return _el$;
    };
  `;
}

// src/core/loader.ts
var URL_PREFIXES = ["/~icons/", "~icons/", "virtual:icons/", "virtual/icons/"];
var iconPathRE = new RegExp(`${URL_PREFIXES.map((v) => `^${v}`).join("|")}`);
function isIconPath(path) {
  return iconPathRE.test(path);
}
function normalizeIconPath(path) {
  return path.replace(iconPathRE, URL_PREFIXES[0]);
}
function resolveIconsPath(path) {
  if (!isIconPath(path))
    return null;
  path = path.replace(iconPathRE, "");
  const query = {};
  const queryIndex = path.indexOf("?");
  if (queryIndex !== -1) {
    const queryRaw = path.slice(queryIndex + 1);
    path = path.slice(0, queryIndex);
    new URLSearchParams(queryRaw).forEach((value, key) => {
      query[value] = key;
    });
  }
  path = path.replace(/\.\w+$/, "");
  const [collection, icon] = path.split("/");
  return {
    collection,
    icon,
    query
  };
}
var _collections = {};
var _idTransforms = [
  (str) => str,
  (str) => str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(),
  (str) => str.replace(/([a-z])(\d+)/g, "$1-$2")
];
function getCollection(name) {
  if (!_collections[name]) {
    const collection = new (0, _jsontools.Collection)();
    collection.loadIconifyCollection(name);
    _collections[name] = collection;
  }
  return _collections[name];
}
function getIcon(name, icon) {
  const collection = getCollection(name);
  if (!collection)
    return null;
  let data;
  for (const trans of _idTransforms) {
    data = collection.getIconData(trans(icon));
    if (data)
      return data;
  }
  return null;
}
async function generateComponent({ collection, icon }, options) {
  const data = getIcon(collection, icon);
  if (!data)
    throw new Error(`Icon \`${collection}:${icon}\` not found`);
  const { scale, defaultStyle, defaultClass } = options;
  const svg = new (0, _jsontools.SVG)(data);
  let svgText = svg.getSVG({
    height: `${scale}em`,
    width: `${scale}em`
  });
  if (!svgText)
    return null;
  if (defaultClass)
    svgText = svgText.replace("<svg ", `<svg class="${defaultClass}" `);
  if (defaultStyle)
    svgText = svgText.replace("<svg ", `<svg style="${defaultStyle}" `);
  if (options.compiler === "jsx")
    return JSXCompiler(svgText, collection, icon, options.jsx);
  else if (options.compiler === "vue2")
    return Vue2Compiler(svgText, collection, icon);
  else if (options.compiler === "vue3")
    return Vue3Compiler(svgText, collection, icon);
  else if (options.compiler === "solid")
    return SolidCompiler(svgText);
  else
    throw new Error(`Unknown compiler: ${options.compiler}`);
}
async function generateComponentFromPath(path, options) {
  const resolved = resolveIconsPath(path);
  if (!resolved)
    return null;
  return generateComponent(resolved, options);
}






exports.isIconPath = isIconPath; exports.normalizeIconPath = normalizeIconPath; exports.getIcon = getIcon; exports.generateComponentFromPath = generateComponentFromPath;
